// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
// Define some constants
#define TWO_PI      6.28318530717958647693

// 소스 메시의 정점을 나타내는 구조체
struct SourceVertex
{
    float3 positionWS; // 월드 공간에서의 위치
    float3 normalOS; // 객체 공간에서의 노멀
    float2 uv; // 폭과 높이 배율을 포함하는 UV 좌표
    float3 color; // 색상 값
};

StructuredBuffer<SourceVertex> _SourceVertices; // 소스 정점들을 저장하는 버퍼
StructuredBuffer<int> _VisibleIDBuffer; // 가시성 ID를 저장하는 버퍼
StructuredBuffer<float> _CutBuffer; // 풀을 자르기 위한 버퍼

// 생성된 메시의 정점을 나타내는 구조체
struct DrawVertex
{
    float3 positionWS; // 월드 공간에서의 위치
    float2 uv; // UV 좌표
};

// 생성된 메시의 삼각형을 나타내는 구조체
struct DrawTriangle
{
    float3 normalOS; // 객체 공간에서의 노멀
    float3 diffuseColor; // 확산 생상
    float4 extraBuffer; // 추가적인 데이터 버퍼
    DrawVertex vertices[3]; // 삼각형을 구성하는 세 개의 정점
};

// 생성된 메시를 저장하는 버퍼
AppendStructuredBuffer<DrawTriangle> _DrawTriangles; // 기록 전용 push만 가능

// GrassCompute 스크립트에 _argsBuffer
struct IndirectArgs
{
    uint numVerticesPerInstance; // 인스턴스당 정점 개수
    uint numInstances; // 인스턴스 개수
    uint startVertexIndex; // 시작 정점 인덱스
    uint startInstanceIndex; // 시작 인스턴스 인덱스
    // uint startLocation;
};

// 커널이 정점 수를 계산하므로 RW 사용 가능해야함
RWStructuredBuffer<IndirectArgs> _IndirectArgsBuffer; // read write 가능한 버퍼

// GrassCompute에서 버퍼 크기를 지정해야 하므로 제한된 값들
#define GRASS_BLADES 10 // 각 정점당 잔디 블레이드 개수
#define GRASS_SEGMENTS 3// 블레이드당 세그먼트 수
#define GRASS_NUM_VERTICES_PER_BLADE (GRASS_SEGMENTS * 2)+ 1    // 블레이드당 정점 수

// ----------------------------------------

/* ==============================
    GrassCompute에서 넣어주는 값들
===============================*/
int _NumSourceVertices; // 소스 정점 개수
float _Time; // 시간 값

// 잔디 설정
float _GrassRandomHeightMin, _GrassRandomHeightMax; // 랜덤 높이의 최소 최대값 

// 바람 설정
float _WindSpeed; // 바람의 속도
float _WindStrength; // 바람의 강도

// 인터랙터 설정
float _InteractorStrength; // 인터랙터의 강도

// 블레이드 설정
float _BladeRadius; //블레이드의 반경
float _BladeForward; //블레이드의 전진량
float _BladeCurve; // 블레이드의 곡률
float _BottomWidth; // 블레이드의 하단 폭
float _MaxBladesPerVertex; // 정점당 최대 블레이드 수
float _MaxSegmentsPerBlade; // 블레이드당 최대 세그먼트 수
float _MinHeight, _MinWidth; // 잔디의 최소 높이 및 폭
float _MaxHeight, _MaxWidth; // 잔디의 최대 높이 및 폭

// 카메라 설정
float _MinFadeDist, _MaxFadeDist; // Fade 최소 및 최대 거리

// Uniforms
uniform float4 _PositionsMoving[100]; // 움직이는 객체들의 위치 정보
uniform float _InteractorsLength; // 인터랙터의 길이
uniform float3 _CameraPositionWS; // 월드 공간에서의 카메라 위치
/* ==============================
    GrassCompute에서 넣어주는 값들
===============================*/

float _GrassHeight; // 잔디의 높이
float _GrassWidth; // 잔디의 폭

// ----------------------------------------
// Helper Functions

// 랜덤 생성 함수
float rand(float3 co)
{
    return frac(sin(dot(co.xyz, float3(12.9898, 78.233, 53.539))) * 43758.5453);
}

// 주어진 범위 내에서 랜덤 값 생성 함수
float RandomRange(float2 Seed, float Min, float Max)
{
    float rand = frac(sin(dot(Seed, float2(12.9898, 78.233))) * 43758.5453);
    return lerp(Min, Max, rand);
}

// 축 중심으로 주어진 각도로 회전하는 회전 행렬 생성 함수
// By Keijiro Takahashi
float3x3 AngleAxis3x3(float angle, float3 axis)
{
    float c, s;
    sincos(angle, s, c);

    float t = 1 - c;
    float x = axis.x;
    float y = axis.y;
    float z = axis.z;

    return float3x3(
        t * x * x + c, t * x * y - s * z, t * x * z + s * y,
        t * x * y + s * z, t * y * y + c, t * y * z - s * x,
        t * x * z - s * y, t * y * z + s * x, t * z * z + c);
}

// 잔디 정점을 생성 
DrawVertex GrassVertex(float3 positionWS, float width, float height,
                       float offset, float curve, float2 uv, float3x3 rotation, float3 growthDirection)
{
    DrawVertex output;
    output.positionWS = positionWS + mul(rotation, float3(width, height, curve + offset)) + growthDirection * height;
    output.uv = uv;
    return output;
}

// ----------------------------------------

// The main kernel
[numthreads(128, 1, 1)]
void Main(uint id : SV_DispatchThreadID)
{
    // Return if every point has been processed
    if ((int)id >= _NumSourceVertices) return;

    // 가시성 ID 버퍼에서 데이터 가져옴
    int visibleID = _VisibleIDBuffer[id];
    if (visibleID == -1) return; // -1 ID는 컬링된 경우 => 그리지 않음

    // 가시성 ID에 해당하는 소스 정점을 가져옴
    SourceVertex sv = _SourceVertices[visibleID];

    // 카메라로부터의 거리 계산 후 페이딩 값 결정
    float distanceFromCamera = distance(sv.positionWS, _CameraPositionWS);
    float distanceFade = 1 - saturate((distanceFromCamera - _MinFadeDist) / (_MaxFadeDist - _MinFadeDist));

    // 카메라가 풀이랑 엄청 가까울 때 풀을 좀 덜 그려서 시야를 덜 가리게 하려고 했던것 ( 딱히 필요없어 보일지도 )
    // float nearFadeDist = 1;
    // float nearFade = saturate((distanceFromCamera - nearFadeDist) / nearFadeDist);

    // float finalFade = distanceFade /** nearFade*/;

    // 페이딩 범위 벗어나면 안그림
    if (distanceFade < 0) return;

    // Blades & Segments
    int numBladesPerVertex = min(GRASS_BLADES, max(1, _MaxBladesPerVertex)); // 정정담 블레이드 수 설정
    int numSegmentsPerBlade = min(GRASS_SEGMENTS, max(1, _MaxSegmentsPerBlade)); // 블레이드당 세그먼트 수 설정
    // -1 is because the top part of the grass only has 1 triangle
    int numTrianglesPerBlade = (numSegmentsPerBlade - 1) * 2 + 1; // 블레이드당 삼각형

    // 노멀 설정
    float3 faceNormal = sv.normalOS; // 객체 공간의 노멀
    float3 growthDirection = normalize(faceNormal + float3(0, -1, 0) * 0.5); // 풀이 자라는 방향 설정

    // 컷팅 값 가져옴
    float cut = _CutBuffer[visibleID];
    // if (cut != -1)
    // {
    //     sv.color = float3(0, 0, 0);
    // }

    // 바람 계산
    float timeWind = _Time.x * _WindSpeed;  // 바람 속도에 따른 시간 값
    float posX = sv.positionWS.x;   // 정점의 X 위치
    float posZ = sv.positionWS.z;   // 정점의 Z 위치
    float3 wind = float3(
        sin(timeWind + posX) + sin(timeWind + posZ * 2) + sin(timeWind * 0.1 + posX),
        0,
        cos(timeWind + posX * 2) + cos(timeWind + posZ));   // 바람 벡터 계산
    wind *= _WindStrength;  // 바람 강도 적용
    
    _GrassHeight = sv.uv.y;
    _GrassWidth = sv.uv.x; // UV.x == width multiplier (set in GrassPainter.cs)
    float randomisedPos = rand(sv.positionWS.xyz);
    // random height offsets
    float randomOffset = RandomRange(sv.positionWS.xz, _GrassRandomHeightMin, _GrassRandomHeightMax);
    _GrassHeight = clamp(_GrassHeight + randomOffset, _MinHeight, _MaxHeight);
    _GrassWidth = clamp(_GrassWidth, _MinWidth, _MaxWidth);
    _GrassWidth *= saturate(distanceFade);
    _BladeForward *= _GrassHeight;

    // 로컬 변수를 사용해 각 스레드에서 처리
    uint localVertexCount = 0;

    // loop to create blade per vertex
    for (int j = 0; j < numBladesPerVertex * distanceFade; j++)
    {
        // vertices arrays
        DrawVertex drawVertices[GRASS_NUM_VERTICES_PER_BLADE];
        // set rotation and radius of the blades
        float3x3 facingRotationMatrix = AngleAxis3x3(randomisedPos * TWO_PI + j, faceNormal);

        float bladeRadius = j / (float)numBladesPerVertex;
        float offset = (1 - bladeRadius) * _BladeRadius;

        float3 totalMovement = 0; // 모든 인터렉터에 의한 총합 이동량
        if (cut == -1)
        {
            // GrassInteractor.cs로 풀 상호작용을 위한 for문
            float3 offsetWorldPos = sv.positionWS + mul(facingRotationMatrix, float3(0, 0, offset));
            // 월드 공간에서 오프셋된 정점 위치
            for (int p = 0; p < _InteractorsLength; p++)
            {
                // 정점에서 인터랙터(상호작용 객체)까지의 벡터 계산
                float3 vertexToInteractor = offsetWorldPos - _PositionsMoving[p].xyz;

                // 정점에서 인터랙터로의 방향 벡터 (정규화된 벡터)
                float3 directionToInteractor = normalize(vertexToInteractor);

                // 인터랙터와 정점 간의 거리 계산 (반지름 포함)
                float distanceToInteractor = abs(length(vertexToInteractor)) + _PositionsMoving[p].w;

                // XZ 평면에서의 오프셋 계산 (Y축 이동은 무시)
                float3 xzOffset = float3(directionToInteractor.x, 0, directionToInteractor.z) * distanceToInteractor;

                // 인터랙터에 의한 이동량 계산 (XZ 오프셋에 따른 이동 - Y축 이동 추가)
                float3 interactorMovement = xzOffset * _InteractorStrength - float3(0, distanceToInteractor * 1, 0);

                // 정점과 인터랙터 사이의 거리 계산
                float3 vertexDistance = distance(_PositionsMoving[p].xyz, offsetWorldPos);

                // 인터랙터 반경 내에서의 상호작용 강도 (0~1 범위로 제한)
                float3 interactionRadius = 1 - saturate(vertexDistance / _PositionsMoving[p].w);

                // 상호작용 반경에 따른 이동량 조정
                interactorMovement *= interactionRadius;

                // 모든 인터랙터의 이동량을 총합
                totalMovement += interactorMovement;
            }
        }
        // create blade
        for (int i = 0; i < numSegmentsPerBlade; i++)
        {
            // taper width, increase height
            float t = i / (float)numSegmentsPerBlade;
            float segmentHeight = _GrassHeight * t; // 풀이 그려지기 시작하는 높이 0이면 바닥부터  1이면 y 1 부터 위로 그려짐
            float segmentWidth = _GrassWidth * (1 - t); // 풀 가로길이 

            // the first (0) grass segment is thinner
            segmentWidth = i == 0 ? _BottomWidth * segmentWidth : segmentWidth; // _BottomWidth변수로 가로길이 조절함

            float segmentForward = pow(abs(t), _BladeCurve) * _BladeForward; // 위쪽 꼭짓점 z값 조절하는거임 xz평면에서 forward임
            // First grass (0) segment does not get displaced by interactor
            float3 newPos = i == 0
                                ? sv.positionWS
                                : sv.positionWS + growthDirection * segmentHeight + totalMovement * t +
                                wind * t; // 노멀 방향으로 위치 조정

            // Append First Vertex        
            drawVertices[i * 2] = GrassVertex(newPos, segmentWidth, segmentHeight, offset, segmentForward,
                                              float2(0, t), facingRotationMatrix, growthDirection);
            // Append Second Vertex
            drawVertices[i * 2 + 1] = GrassVertex(newPos, -segmentWidth, segmentHeight, offset, segmentForward,
                                                  float2(1, t), facingRotationMatrix, growthDirection);
        }
        // Append Top Vertex
        float3 topPosOS = sv.positionWS + totalMovement + wind + faceNormal * _GrassHeight;
        drawVertices[numSegmentsPerBlade * 2] = GrassVertex(topPosOS, 0, _GrassHeight, offset, _BladeForward,
                                                            float2(0.5, 1), facingRotationMatrix, growthDirection);

        // add to indirect arguments buffer with the correct vertexcount       
        // InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, numTrianglesPerBlade * 3);

        // add to the drawbuffer to be read by the final shader
        for (int k = 0; k < numTrianglesPerBlade; ++k)
        {
            DrawTriangle tri = (DrawTriangle)0;
            tri.normalOS = faceNormal;
            tri.diffuseColor = sv.color;
            tri.extraBuffer = float4(cut, 0, 0, 0);
            tri.vertices[0] = drawVertices[k];
            tri.vertices[1] = drawVertices[k + 1];
            tri.vertices[2] = drawVertices[k + 2];
            _DrawTriangles.Append(tri);

            localVertexCount += 3;
        }
    }

    // add to indirect arguments buffer with the correct vertexcount       
    InterlockedAdd(_IndirectArgsBuffer[0].numVerticesPerInstance, localVertexCount);
}
